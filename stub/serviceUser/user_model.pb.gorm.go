package serviceUser

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type AccessibilityORM struct {
	AccentColor   *ColorORM `gorm:"foreignkey:AccentColorID;association_foreignkey:Id"`
	AccentColorID *uint64
	AccentColorId uint64 `gorm:"not null"`
	CreatedAt     *time.Time
	DarkMode      bool   `gorm:"default:false;not null"`
	Id            uint64 `gorm:"primary_key;not null"`
	Transparency  bool   `gorm:"default:true;not null"`
	UpdatedAt     *time.Time
}

// TableName overrides the default tablename generated by GORM
func (AccessibilityORM) TableName() string {
	return "accessibilities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Accessibility) ToORM(ctx context.Context) (AccessibilityORM, error) {
	to := AccessibilityORM{}
	var err error
	if prehook, ok := interface{}(m).(AccessibilityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DarkMode = m.DarkMode
	to.Transparency = m.Transparency
	to.AccentColorId = m.AccentColorId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.AccentColor != nil {
		tempAccentColor, err := m.AccentColor.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.AccentColor = &tempAccentColor
	}
	if posthook, ok := interface{}(m).(AccessibilityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccessibilityORM) ToPB(ctx context.Context) (Accessibility, error) {
	to := Accessibility{}
	var err error
	if prehook, ok := interface{}(m).(AccessibilityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DarkMode = m.DarkMode
	to.Transparency = m.Transparency
	to.AccentColorId = m.AccentColorId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.AccentColor != nil {
		tempAccentColor, err := m.AccentColor.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.AccentColor = &tempAccentColor
	}
	if posthook, ok := interface{}(m).(AccessibilityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Accessibility the arg will be the target, the caller the one being converted from

// AccessibilityBeforeToORM called before default ToORM code
type AccessibilityWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccessibilityORM) error
}

// AccessibilityAfterToORM called after default ToORM code
type AccessibilityWithAfterToORM interface {
	AfterToORM(context.Context, *AccessibilityORM) error
}

// AccessibilityBeforeToPB called before default ToPB code
type AccessibilityWithBeforeToPB interface {
	BeforeToPB(context.Context, *Accessibility) error
}

// AccessibilityAfterToPB called after default ToPB code
type AccessibilityWithAfterToPB interface {
	AfterToPB(context.Context, *Accessibility) error
}

type ColorORM struct {
	Accessibilities []*AccessibilityORM `gorm:"foreignkey:AccentColorID;association_foreignkey:Id"`
	Code            string
	CreatedAt       *time.Time
	Id              uint64 `gorm:"primary_key;not null"`
	Name            string
	UpdatedAt       *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ColorORM) TableName() string {
	return "colors"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Color) ToORM(ctx context.Context) (ColorORM, error) {
	to := ColorORM{}
	var err error
	if prehook, ok := interface{}(m).(ColorWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.Accessibilities {
		if v != nil {
			if tempAccessibilities, cErr := v.ToORM(ctx); cErr == nil {
				to.Accessibilities = append(to.Accessibilities, &tempAccessibilities)
			} else {
				return to, cErr
			}
		} else {
			to.Accessibilities = append(to.Accessibilities, nil)
		}
	}
	if posthook, ok := interface{}(m).(ColorWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ColorORM) ToPB(ctx context.Context) (Color, error) {
	to := Color{}
	var err error
	if prehook, ok := interface{}(m).(ColorWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.Accessibilities {
		if v != nil {
			if tempAccessibilities, cErr := v.ToPB(ctx); cErr == nil {
				to.Accessibilities = append(to.Accessibilities, &tempAccessibilities)
			} else {
				return to, cErr
			}
		} else {
			to.Accessibilities = append(to.Accessibilities, nil)
		}
	}
	if posthook, ok := interface{}(m).(ColorWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Color the arg will be the target, the caller the one being converted from

// ColorBeforeToORM called before default ToORM code
type ColorWithBeforeToORM interface {
	BeforeToORM(context.Context, *ColorORM) error
}

// ColorAfterToORM called after default ToORM code
type ColorWithAfterToORM interface {
	AfterToORM(context.Context, *ColorORM) error
}

// ColorBeforeToPB called before default ToPB code
type ColorWithBeforeToPB interface {
	BeforeToPB(context.Context, *Color) error
}

// ColorAfterToPB called after default ToPB code
type ColorWithAfterToPB interface {
	AfterToPB(context.Context, *Color) error
}

type FeatureORM struct {
	Code                  string `gorm:"not null"`
	CreatedAt             *time.Time
	Id                    uint64                     `gorm:"primary_key;not null"`
	Name                  string                     `gorm:"not null"`
	NotificationsFeatures []*NotificationsFeatureORM `gorm:"foreignkey:FeatureID;association_foreignkey:Id"`
	UpdatedAt             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (FeatureORM) TableName() string {
	return "features"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Feature) ToORM(ctx context.Context) (FeatureORM, error) {
	to := FeatureORM{}
	var err error
	if prehook, ok := interface{}(m).(FeatureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.NotificationsFeatures {
		if v != nil {
			if tempNotificationsFeatures, cErr := v.ToORM(ctx); cErr == nil {
				to.NotificationsFeatures = append(to.NotificationsFeatures, &tempNotificationsFeatures)
			} else {
				return to, cErr
			}
		} else {
			to.NotificationsFeatures = append(to.NotificationsFeatures, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeatureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeatureORM) ToPB(ctx context.Context) (Feature, error) {
	to := Feature{}
	var err error
	if prehook, ok := interface{}(m).(FeatureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.NotificationsFeatures {
		if v != nil {
			if tempNotificationsFeatures, cErr := v.ToPB(ctx); cErr == nil {
				to.NotificationsFeatures = append(to.NotificationsFeatures, &tempNotificationsFeatures)
			} else {
				return to, cErr
			}
		} else {
			to.NotificationsFeatures = append(to.NotificationsFeatures, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeatureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Feature the arg will be the target, the caller the one being converted from

// FeatureBeforeToORM called before default ToORM code
type FeatureWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeatureORM) error
}

// FeatureAfterToORM called after default ToORM code
type FeatureWithAfterToORM interface {
	AfterToORM(context.Context, *FeatureORM) error
}

// FeatureBeforeToPB called before default ToPB code
type FeatureWithBeforeToPB interface {
	BeforeToPB(context.Context, *Feature) error
}

// FeatureAfterToPB called after default ToPB code
type FeatureWithAfterToPB interface {
	AfterToPB(context.Context, *Feature) error
}

type NotificationsFeatureORM struct {
	CreatedAt *time.Time
	Feature   *FeatureORM `gorm:"foreignkey:FeatureID;association_foreignkey:Id"`
	FeatureID *uint64
	FeatureId uint64      `gorm:"not null"`
	Id        uint64      `gorm:"primary_key;not null"`
	IsEnabled bool        `gorm:"default:false;not null"`
	Setting   *SettingORM `gorm:"foreignkey:SettingID;association_foreignkey:Id"`
	SettingID *uint64
	SettingId uint64 `gorm:"not null"`
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationsFeatureORM) TableName() string {
	return "notifications_features"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationsFeature) ToORM(ctx context.Context) (NotificationsFeatureORM, error) {
	to := NotificationsFeatureORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationsFeatureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FeatureId = m.FeatureId
	to.SettingId = m.SettingId
	to.IsEnabled = m.IsEnabled
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.Feature != nil {
		tempFeature, err := m.Feature.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Feature = &tempFeature
	}
	if m.Setting != nil {
		tempSetting, err := m.Setting.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Setting = &tempSetting
	}
	if posthook, ok := interface{}(m).(NotificationsFeatureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationsFeatureORM) ToPB(ctx context.Context) (NotificationsFeature, error) {
	to := NotificationsFeature{}
	var err error
	if prehook, ok := interface{}(m).(NotificationsFeatureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FeatureId = m.FeatureId
	to.SettingId = m.SettingId
	to.IsEnabled = m.IsEnabled
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.Feature != nil {
		tempFeature, err := m.Feature.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Feature = &tempFeature
	}
	if m.Setting != nil {
		tempSetting, err := m.Setting.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Setting = &tempSetting
	}
	if posthook, ok := interface{}(m).(NotificationsFeatureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationsFeature the arg will be the target, the caller the one being converted from

// NotificationsFeatureBeforeToORM called before default ToORM code
type NotificationsFeatureWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationsFeatureORM) error
}

// NotificationsFeatureAfterToORM called after default ToORM code
type NotificationsFeatureWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationsFeatureORM) error
}

// NotificationsFeatureBeforeToPB called before default ToPB code
type NotificationsFeatureWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationsFeature) error
}

// NotificationsFeatureAfterToPB called after default ToPB code
type NotificationsFeatureWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationsFeature) error
}

type SettingORM struct {
	Accessibility         *AccessibilityORM `gorm:"foreignkey:AccessibilityID;association_foreignkey:Id"`
	AccessibilityID       *uint64
	AccessibilityId       uint64 `gorm:"not null"`
	CreatedAt             *time.Time
	Id                    uint64                     `gorm:"primary_key;not null"`
	NotificationsFeatures []*NotificationsFeatureORM `gorm:"foreignkey:SettingID;association_foreignkey:Id"`
	UpdatedAt             *time.Time
	Username              string
}

// TableName overrides the default tablename generated by GORM
func (SettingORM) TableName() string {
	return "settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Setting) ToORM(ctx context.Context) (SettingORM, error) {
	to := SettingORM{}
	var err error
	if prehook, ok := interface{}(m).(SettingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.AccessibilityId = m.AccessibilityId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.Accessibility != nil {
		tempAccessibility, err := m.Accessibility.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Accessibility = &tempAccessibility
	}
	for _, v := range m.NotificationsFeatures {
		if v != nil {
			if tempNotificationsFeatures, cErr := v.ToORM(ctx); cErr == nil {
				to.NotificationsFeatures = append(to.NotificationsFeatures, &tempNotificationsFeatures)
			} else {
				return to, cErr
			}
		} else {
			to.NotificationsFeatures = append(to.NotificationsFeatures, nil)
		}
	}
	if posthook, ok := interface{}(m).(SettingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SettingORM) ToPB(ctx context.Context) (Setting, error) {
	to := Setting{}
	var err error
	if prehook, ok := interface{}(m).(SettingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.AccessibilityId = m.AccessibilityId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.Accessibility != nil {
		tempAccessibility, err := m.Accessibility.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Accessibility = &tempAccessibility
	}
	for _, v := range m.NotificationsFeatures {
		if v != nil {
			if tempNotificationsFeatures, cErr := v.ToPB(ctx); cErr == nil {
				to.NotificationsFeatures = append(to.NotificationsFeatures, &tempNotificationsFeatures)
			} else {
				return to, cErr
			}
		} else {
			to.NotificationsFeatures = append(to.NotificationsFeatures, nil)
		}
	}
	if posthook, ok := interface{}(m).(SettingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Setting the arg will be the target, the caller the one being converted from

// SettingBeforeToORM called before default ToORM code
type SettingWithBeforeToORM interface {
	BeforeToORM(context.Context, *SettingORM) error
}

// SettingAfterToORM called after default ToORM code
type SettingWithAfterToORM interface {
	AfterToORM(context.Context, *SettingORM) error
}

// SettingBeforeToPB called before default ToPB code
type SettingWithBeforeToPB interface {
	BeforeToPB(context.Context, *Setting) error
}

// SettingAfterToPB called after default ToPB code
type SettingWithAfterToPB interface {
	AfterToPB(context.Context, *Setting) error
}

// DefaultCreateAccessibility executes a basic gorm create call
func DefaultCreateAccessibility(ctx context.Context, in *Accessibility, db *gorm.DB) (*Accessibility, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccessibilityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccessibility(ctx context.Context, in *Accessibility, db *gorm.DB) (*Accessibility, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccessibilityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccessibilityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccessibilityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccessibilityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccessibility(ctx context.Context, in *Accessibility, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccessibilityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccessibilityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccessibilitySet(ctx context.Context, in []*Accessibility, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccessibilityORM{})).(AccessibilityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccessibilityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccessibilityORM{})).(AccessibilityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccessibilityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Accessibility, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Accessibility, *gorm.DB) error
}

// DefaultStrictUpdateAccessibility clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccessibility(ctx context.Context, in *Accessibility, db *gorm.DB) (*Accessibility, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccessibility")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccessibilityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccessibilityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccessibility executes a basic gorm update call with patch behavior
func DefaultPatchAccessibility(ctx context.Context, in *Accessibility, updateMask *field_mask.FieldMask, db *gorm.DB) (*Accessibility, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Accessibility
	var err error
	if hook, ok := interface{}(&pbObj).(AccessibilityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccessibility(ctx, &Accessibility{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccessibilityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccessibility(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccessibilityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccessibility(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccessibilityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccessibilityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Accessibility, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Accessibility, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Accessibility, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Accessibility, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccessibility executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccessibility(ctx context.Context, objects []*Accessibility, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Accessibility, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Accessibility, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccessibility(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccessibility patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccessibility(ctx context.Context, patchee *Accessibility, patcher *Accessibility, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Accessibility, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedAccentColor bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"DarkMode" {
			patchee.DarkMode = patcher.DarkMode
			continue
		}
		if f == prefix+"Transparency" {
			patchee.Transparency = patcher.Transparency
			continue
		}
		if f == prefix+"AccentColorId" {
			patchee.AccentColorId = patcher.AccentColorId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedAccentColor && strings.HasPrefix(f, prefix+"AccentColor.") {
			updatedAccentColor = true
			if patcher.AccentColor == nil {
				patchee.AccentColor = nil
				continue
			}
			if patchee.AccentColor == nil {
				patchee.AccentColor = &Color{}
			}
			if o, err := DefaultApplyFieldMaskColor(ctx, patchee.AccentColor, patcher.AccentColor, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"AccentColor.", db); err != nil {
				return nil, err
			} else {
				patchee.AccentColor = o
			}
			continue
		}
		if f == prefix+"AccentColor" {
			updatedAccentColor = true
			patchee.AccentColor = patcher.AccentColor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccessibility executes a gorm list call
func DefaultListAccessibility(ctx context.Context, db *gorm.DB) ([]*Accessibility, error) {
	in := Accessibility{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccessibilityORM{}, &Accessibility{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccessibilityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccessibilityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Accessibility{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccessibilityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccessibilityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccessibilityORM) error
}

// DefaultCreateColor executes a basic gorm create call
func DefaultCreateColor(ctx context.Context, in *Color, db *gorm.DB) (*Color, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ColorORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadColor(ctx context.Context, in *Color, db *gorm.DB) (*Color, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ColorORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ColorORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ColorORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ColorORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteColor(ctx context.Context, in *Color, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ColorORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ColorORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteColorSet(ctx context.Context, in []*Color, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ColorORM{})).(ColorORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ColorORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ColorORM{})).(ColorORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ColorORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Color, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Color, *gorm.DB) error
}

// DefaultStrictUpdateColor clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateColor(ctx context.Context, in *Color, db *gorm.DB) (*Color, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateColor")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ColorORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccessibilities := AccessibilityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccessibilities.AccentColorID = new(uint64)
	*filterAccessibilities.AccentColorID = ormObj.Id
	if err = db.Where(filterAccessibilities).Delete(AccessibilityORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ColorORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchColor executes a basic gorm update call with patch behavior
func DefaultPatchColor(ctx context.Context, in *Color, updateMask *field_mask.FieldMask, db *gorm.DB) (*Color, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Color
	var err error
	if hook, ok := interface{}(&pbObj).(ColorWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadColor(ctx, &Color{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ColorWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskColor(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ColorWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateColor(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ColorWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ColorWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Color, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ColorWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Color, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ColorWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Color, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ColorWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Color, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetColor executes a bulk gorm update call with patch behavior
func DefaultPatchSetColor(ctx context.Context, objects []*Color, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Color, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Color, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchColor(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskColor patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskColor(ctx context.Context, patchee *Color, patcher *Color, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Color, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Accessibilities" {
			patchee.Accessibilities = patcher.Accessibilities
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListColor executes a gorm list call
func DefaultListColor(ctx context.Context, db *gorm.DB) ([]*Color, error) {
	in := Color{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ColorORM{}, &Color{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ColorORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ColorORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Color{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ColorORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ColorORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ColorORM) error
}

// DefaultCreateFeature executes a basic gorm create call
func DefaultCreateFeature(ctx context.Context, in *Feature, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeatureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFeature(ctx context.Context, in *Feature, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FeatureORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeatureORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeatureORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeatureORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFeature(ctx context.Context, in *Feature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeatureORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFeatureSet(ctx context.Context, in []*Feature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeatureORM{})).(FeatureORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeatureORM{})).(FeatureORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeatureORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Feature, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Feature, *gorm.DB) error
}

// DefaultStrictUpdateFeature clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeature(ctx context.Context, in *Feature, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeature")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeatureORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotificationsFeatures := NotificationsFeatureORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationsFeatures.FeatureID = new(uint64)
	*filterNotificationsFeatures.FeatureID = ormObj.Id
	if err = db.Where(filterNotificationsFeatures).Delete(NotificationsFeatureORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeatureORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFeature executes a basic gorm update call with patch behavior
func DefaultPatchFeature(ctx context.Context, in *Feature, updateMask *field_mask.FieldMask, db *gorm.DB) (*Feature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Feature
	var err error
	if hook, ok := interface{}(&pbObj).(FeatureWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeature(ctx, &Feature{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeatureWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeature(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeatureWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeature(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeatureWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeatureWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FeatureWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Feature, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFeature executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeature(ctx context.Context, objects []*Feature, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Feature, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Feature, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeature(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeature patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeature(ctx context.Context, patchee *Feature, patcher *Feature, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Feature, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"NotificationsFeatures" {
			patchee.NotificationsFeatures = patcher.NotificationsFeatures
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeature executes a gorm list call
func DefaultListFeature(ctx context.Context, db *gorm.DB) ([]*Feature, error) {
	in := Feature{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FeatureORM{}, &Feature{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeatureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeatureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Feature{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeatureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FeatureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FeatureORM) error
}

// DefaultCreateNotificationsFeature executes a basic gorm create call
func DefaultCreateNotificationsFeature(ctx context.Context, in *NotificationsFeature, db *gorm.DB) (*NotificationsFeature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationsFeatureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationsFeature(ctx context.Context, in *NotificationsFeature, db *gorm.DB) (*NotificationsFeature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationsFeatureORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationsFeatureORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationsFeatureORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationsFeatureORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationsFeature(ctx context.Context, in *NotificationsFeature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationsFeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationsFeatureORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationsFeatureSet(ctx context.Context, in []*NotificationsFeature, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationsFeatureORM{})).(NotificationsFeatureORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NotificationsFeatureORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationsFeatureORM{})).(NotificationsFeatureORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationsFeatureORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationsFeature, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationsFeature, *gorm.DB) error
}

// DefaultStrictUpdateNotificationsFeature clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationsFeature(ctx context.Context, in *NotificationsFeature, db *gorm.DB) (*NotificationsFeature, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationsFeature")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationsFeatureORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationsFeatureORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationsFeature executes a basic gorm update call with patch behavior
func DefaultPatchNotificationsFeature(ctx context.Context, in *NotificationsFeature, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationsFeature, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationsFeature
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationsFeatureWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotificationsFeature(ctx, &NotificationsFeature{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationsFeatureWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationsFeature(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationsFeatureWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationsFeature(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationsFeatureWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationsFeatureWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationsFeature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationsFeature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationsFeature, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationsFeature, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationsFeature executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationsFeature(ctx context.Context, objects []*NotificationsFeature, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationsFeature, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationsFeature, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationsFeature(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationsFeature patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationsFeature(ctx context.Context, patchee *NotificationsFeature, patcher *NotificationsFeature, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationsFeature, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedFeature bool
	var updatedSetting bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FeatureId" {
			patchee.FeatureId = patcher.FeatureId
			continue
		}
		if f == prefix+"SettingId" {
			patchee.SettingId = patcher.SettingId
			continue
		}
		if f == prefix+"IsEnabled" {
			patchee.IsEnabled = patcher.IsEnabled
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedFeature && strings.HasPrefix(f, prefix+"Feature.") {
			updatedFeature = true
			if patcher.Feature == nil {
				patchee.Feature = nil
				continue
			}
			if patchee.Feature == nil {
				patchee.Feature = &Feature{}
			}
			if o, err := DefaultApplyFieldMaskFeature(ctx, patchee.Feature, patcher.Feature, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Feature.", db); err != nil {
				return nil, err
			} else {
				patchee.Feature = o
			}
			continue
		}
		if f == prefix+"Feature" {
			updatedFeature = true
			patchee.Feature = patcher.Feature
			continue
		}
		if !updatedSetting && strings.HasPrefix(f, prefix+"Setting.") {
			updatedSetting = true
			if patcher.Setting == nil {
				patchee.Setting = nil
				continue
			}
			if patchee.Setting == nil {
				patchee.Setting = &Setting{}
			}
			if o, err := DefaultApplyFieldMaskSetting(ctx, patchee.Setting, patcher.Setting, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Setting.", db); err != nil {
				return nil, err
			} else {
				patchee.Setting = o
			}
			continue
		}
		if f == prefix+"Setting" {
			updatedSetting = true
			patchee.Setting = patcher.Setting
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationsFeature executes a gorm list call
func DefaultListNotificationsFeature(ctx context.Context, db *gorm.DB) ([]*NotificationsFeature, error) {
	in := NotificationsFeature{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationsFeatureORM{}, &NotificationsFeature{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationsFeatureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationsFeatureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationsFeature{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationsFeatureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationsFeatureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationsFeatureORM) error
}

// DefaultCreateSetting executes a basic gorm create call
func DefaultCreateSetting(ctx context.Context, in *Setting, db *gorm.DB) (*Setting, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SettingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSetting(ctx context.Context, in *Setting, db *gorm.DB) (*Setting, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SettingORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SettingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SettingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SettingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSetting(ctx context.Context, in *Setting, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SettingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SettingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSettingSet(ctx context.Context, in []*Setting, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SettingORM{})).(SettingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SettingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SettingORM{})).(SettingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SettingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Setting, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Setting, *gorm.DB) error
}

// DefaultStrictUpdateSetting clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSetting(ctx context.Context, in *Setting, db *gorm.DB) (*Setting, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSetting")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SettingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotificationsFeatures := NotificationsFeatureORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationsFeatures.SettingID = new(uint64)
	*filterNotificationsFeatures.SettingID = ormObj.Id
	if err = db.Where(filterNotificationsFeatures).Delete(NotificationsFeatureORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SettingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSetting executes a basic gorm update call with patch behavior
func DefaultPatchSetting(ctx context.Context, in *Setting, updateMask *field_mask.FieldMask, db *gorm.DB) (*Setting, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Setting
	var err error
	if hook, ok := interface{}(&pbObj).(SettingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSetting(ctx, &Setting{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SettingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSetting(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SettingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSetting(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SettingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SettingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Setting, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Setting, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Setting, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Setting, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSetting executes a bulk gorm update call with patch behavior
func DefaultPatchSetSetting(ctx context.Context, objects []*Setting, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Setting, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Setting, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSetting(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSetting patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSetting(ctx context.Context, patchee *Setting, patcher *Setting, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Setting, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedAccessibility bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"AccessibilityId" {
			patchee.AccessibilityId = patcher.AccessibilityId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedAccessibility && strings.HasPrefix(f, prefix+"Accessibility.") {
			updatedAccessibility = true
			if patcher.Accessibility == nil {
				patchee.Accessibility = nil
				continue
			}
			if patchee.Accessibility == nil {
				patchee.Accessibility = &Accessibility{}
			}
			if o, err := DefaultApplyFieldMaskAccessibility(ctx, patchee.Accessibility, patcher.Accessibility, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Accessibility.", db); err != nil {
				return nil, err
			} else {
				patchee.Accessibility = o
			}
			continue
		}
		if f == prefix+"Accessibility" {
			updatedAccessibility = true
			patchee.Accessibility = patcher.Accessibility
			continue
		}
		if f == prefix+"NotificationsFeatures" {
			patchee.NotificationsFeatures = patcher.NotificationsFeatures
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSetting executes a gorm list call
func DefaultListSetting(ctx context.Context, db *gorm.DB) ([]*Setting, error) {
	in := Setting{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SettingORM{}, &Setting{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SettingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Setting{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SettingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SettingORM) error
}
